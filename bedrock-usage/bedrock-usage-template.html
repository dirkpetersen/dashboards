<!DOCTYPE html>
<html>
<head>
    <title>AWS Bedrock Usage Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        h1 {
            color: #232f3e;
            border-bottom: 4px solid #ff9900;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 32px;
        }
        .loading {
            text-align: center;
            padding: 60px;
            color: #666;
            font-size: 18px;
        }
        .error {
            background-color: #fee;
            border-left: 4px solid #c00;
            padding: 20px;
            border-radius: 8px;
            color: #c00;
            margin: 20px 0;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 25px;
            border-radius: 12px;
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: transform 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-5px);
        }
        .stat-card.cost {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .stat-card.tokens {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .stat-card.invocations {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        .stat-card h3 {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
            font-weight: 500;
        }
        .stat-card .value {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-card .subtitle {
            font-size: 12px;
            opacity: 0.8;
        }

        /* Chart Sections */
        .chart-section {
            margin: 40px 0;
            background-color: #f8f9fa;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .chart-section h2 {
            color: #232f3e;
            margin-bottom: 20px;
            font-size: 22px;
            border-left: 4px solid #ff9900;
            padding-left: 15px;
        }
        .chart-container {
            height: 400px;
            position: relative;
        }

        /* Two column layout for charts */
        .chart-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 25px 0;
        }
        @media (max-width: 1200px) {
            .chart-row {
                grid-template-columns: 1fr;
            }
        }

        /* Table styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .data-table th {
            background-color: #232f3e;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        .data-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        .data-table tr:hover {
            background-color: #f5f5f5;
        }
        .data-table tr:last-child td {
            border-bottom: none;
        }
        .data-table .number {
            text-align: right;
            font-family: 'Courier New', monospace;
        }
        .data-table .cost {
            color: #f5576c;
            font-weight: 600;
        }

        .header-toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .header-toolbar select,
        .header-toolbar a {
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            text-decoration: none;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
        }

        .header-toolbar select {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            color: #232f3e;
        }

        .header-toolbar select:hover {
            border-color: #667eea;
        }

        .header-toolbar a.btn-matrix {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(67, 233, 123, 0.4);
        }

        .header-toolbar a.btn-matrix:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(67, 233, 123, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
            <div>
                <h1 style="margin: 0;">ðŸš€ AWS Bedrock Usage Dashboard</h1>
                <div class="header-toolbar">
                    <label style="font-size: 14px; color: #666; margin-right: 5px;">Date Range:</label>
                    <select id="daysDropdown" onchange="changeDays()">
                        <option value="1">Last Day</option>
                        <option value="7" selected>Last 7 days</option>
                        <option value="30">Last 30 days</option>
                        <option value="90">Last 90 days</option>
                    </select>
                </div>
            </div>
            <a href="/pricing" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 24px; border-radius: 8px; text-decoration: none; font-weight: 600; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">ðŸ’° View Pricing</a>
        </div>
        <div id="loading" class="loading">Loading data from AWS...</div>
        <div id="error" style="display:none;" class="error"></div>

        <div id="content" style="display:none;">
            <!-- Summary Stats -->
            <div class="stats-grid" id="stats"></div>

            <!-- Charts -->
            <div class="chart-section">
                <h2>ðŸ’° Cost Analysis</h2>
                <div class="chart-container">
                    <canvas id="userDailyCostChart"></canvas>
                </div>
                <div style="margin-top: 30px;">
                    <div class="chart-container" style="margin-bottom: 30px;">
                        <h3>ðŸ‘¥ Cost Distribution by User and Model</h3>
                        <canvas id="costByUserChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <h3>ðŸ“Š Cost Distribution by Model and User</h3>
                        <canvas id="costMatrixChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-section">
                <h2>ðŸ”¢ Token Usage</h2>
                <div class="chart-row">
                    <div class="chart-container">
                        <canvas id="tokensByUserChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="tokensByModelChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-section">
                <h2>ðŸ“Š Invocations</h2>
                <div class="chart-row">
                    <div class="chart-container">
                        <canvas id="invocationsByUserChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="invocationsByModelChart"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="dailyTrendChart"></canvas>
                </div>
            </div>

            <!-- Detailed Table -->
            <div class="chart-section">
                <h2>ðŸ“‹ Detailed Breakdown by Model</h2>
                <table class="data-table" id="modelTable">
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th class="number">Invocations</th>
                            <th class="number">Input Tokens</th>
                            <th class="number">Output Tokens</th>
                            <th class="number">Cost</th>
                        </tr>
                    </thead>
                    <tbody id="modelTableBody"></tbody>
                </table>
            </div>

            <div class="chart-section">
                <h2>ðŸ‘¥ Detailed Breakdown by User</h2>
                <table class="data-table" id="userTable">
                    <thead>
                        <tr>
                            <th>User</th>
                            <th class="number">Invocations</th>
                            <th class="number">Input Tokens</th>
                            <th class="number">Output Tokens</th>
                            <th class="number">Total Tokens</th>
                            <th class="number">Cost</th>
                        </tr>
                    </thead>
                    <tbody id="userTableBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let chartInstances = {};

        function getDaysParameter() {
            const urlParams = new URLSearchParams(window.location.search);
            const days = urlParams.get('days') || '7';
            return days;
        }

        function changeDays() {
            const days = document.getElementById('daysDropdown').value;
            window.location.search = `?days=${days}`;
        }

        async function loadData() {
            try {
                const days = getDaysParameter();
                const response = await fetch(`/api/usage?days=${days}`);
                const data = await response.json();

                if (data.error) {
                    showError(data.error);
                    return;
                }

                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                // Update the dropdown to show the current selection
                document.getElementById('daysDropdown').value = days;

                renderStats(data);
                renderCostCharts(data);
                renderTokenCharts(data);
                renderInvocationCharts(data);
                renderTables(data);
            } catch (error) {
                showError('Failed to load data: ' + error.message);
            }
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = message;
        }

        function formatNumber(num) {
            return num.toLocaleString();
        }

        function formatCost(cost) {
            return '$' + cost.toFixed(2);
        }

        function renderStats(data) {
            const statsDiv = document.getElementById('stats');
            const totalInvocations = Object.values(data.user_invocations).reduce((a, b) => a + b, 0);
            const totalUsers = Object.keys(data.user_invocations).length;
            const totalModels = Object.keys(data.model_usage).length;

            statsDiv.innerHTML = `
                <div class="stat-card cost">
                    <h3>Total Cost</h3>
                    <div class="value">${formatCost(data.total_cost || 0)}</div>
                    <div class="subtitle">${data.date_range}</div>
                </div>
                <div class="stat-card invocations">
                    <h3>Total Invocations</h3>
                    <div class="value">${formatNumber(totalInvocations)}</div>
                    <div class="subtitle">${totalUsers} users, ${totalModels} models</div>
                </div>
                <div class="stat-card tokens">
                    <h3>Input Tokens</h3>
                    <div class="value">${formatNumber(data.total_input_tokens || 0)}</div>
                    <div class="subtitle">Total tokens sent</div>
                </div>
                <div class="stat-card tokens">
                    <h3>Output Tokens</h3>
                    <div class="value">${formatNumber(data.total_output_tokens || 0)}</div>
                    <div class="subtitle">Total tokens generated</div>
                </div>
            `;
        }

        function renderCostCharts(data) {
            // Build daily cost chart with dates on X-axis and user+model lines
            // Use filtered data for graphs (only models with >= 25 invocations)
            const userModelDailyCosts = data.user_model_daily_costs_for_graphs || {};
            const modelDisplayNames = data.model_display_names_for_graphs || {};
            const dailyCosts = data.daily_costs || {};

            if (Object.keys(userModelDailyCosts).length === 0) {
                // Fallback if no daily data
                renderCostDistributionCharts(data);
                return;
            }

            // Collect all dates and sort them
            const allDates = new Set();
            Object.values(userModelDailyCosts).forEach(userModels => {
                Object.values(userModels).forEach(dailyData => {
                    Object.keys(dailyData).forEach(date => allDates.add(date));
                });
            });
            const sortedDates = Array.from(allDates).sort();

            // Calculate average daily cost per user
            const userAverageCosts = {};
            Object.keys(userModelDailyCosts).forEach(user => {
                const userModels = userModelDailyCosts[user];
                let totalCost = 0;
                let costCount = 0;

                Object.values(userModels).forEach(dailyData => {
                    Object.values(dailyData).forEach(cost => {
                        totalCost += cost;
                        costCount++;
                    });
                });

                userAverageCosts[user] = costCount > 0 ? totalCost / sortedDates.length : 0;
            });

            // Filter users: keep only those with average daily cost >= $1
            const filteredUsers = Object.keys(userModelDailyCosts)
                .filter(user => userAverageCosts[user] >= 1.0)
                .sort();

            // Create color palette
            const colors = [
                '#667eea', '#764ba2', '#f5576c', '#f093fb', '#4facfe', '#00f2fe',
                '#43e97b', '#38f9d7', '#fa709a', '#fee140', '#30b0fe', '#ff6b6b',
                '#ee5a6f', '#c44569', '#f8b500', '#56ab91', '#a8e6cf', '#ffa07a'
            ];

            // Build datasets: one for each user+model combination (filtered)
            const datasets = [];
            let colorIdx = 0;

            filteredUsers.forEach(user => {
                const userModels = userModelDailyCosts[user] || {};
                const models = Object.keys(userModels).sort();

                models.forEach(model => {
                    const dailyData = userModels[model] || {};
                    const displayName = modelDisplayNames[model] || model;
                    const lineLabel = `${user} (${displayName})`;

                    // Build data array for all dates
                    const dataPoints = sortedDates.map(date => {
                        const cost = dailyData[date] || 0;
                        return parseFloat(cost.toFixed(2));
                    });

                    datasets.push({
                        label: lineLabel,
                        data: dataPoints,
                        borderColor: colors[colorIdx % colors.length],
                        backgroundColor: colors[colorIdx % colors.length] + '33',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        borderWidth: 2
                    });
                    colorIdx++;
                });
            });

            // Add total cost line with thicker stroke and dashed style
            const totalDailyPoints = sortedDates.map(date => {
                const cost = dailyCosts[date] || 0;
                return parseFloat(cost.toFixed(2));
            });

            datasets.push({
                label: 'Total Cost',
                data: totalDailyPoints,
                borderColor: '#000',
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.4,
                pointRadius: 5,
                pointHoverRadius: 7,
                borderWidth: 3,
                borderDash: [5, 5]
            });

            // Create the daily cost line chart
            createDailyLineChart('userDailyCostChart', 'Daily Cost by User and Model (users > $1/day)',
                sortedDates,
                datasets);

            // Cost Distribution Charts - using user_model_costs data
            renderCostDistributionCharts(data);
        }

        function renderCostDistributionCharts(data) {
            // Use filtered data for graphs (only models with >= 25 invocations)
            const userModelCosts = data.user_model_costs_for_graphs || {};
            if (Object.keys(userModelCosts).length === 0) return;

            // Build matrix for distribution charts
            const users = Object.keys(userModelCosts).sort();
            const allModels = new Set();
            Object.values(userModelCosts).forEach(costs => {
                Object.keys(costs).forEach(m => allModels.add(m));
            });
            const models = Array.from(allModels).sort();
            const modelDisplayNames = data.model_display_names_for_graphs || {};

            // Create transposed matrix (models as rows, users as columns)
            const transposedMatrix = [];
            for (let modelIdx = 0; modelIdx < models.length; modelIdx++) {
                const row = [];
                for (let userIdx = 0; userIdx < users.length; userIdx++) {
                    const cost = userModelCosts[users[userIdx]][models[modelIdx]] || 0;
                    row.push(cost);
                }
                transposedMatrix.push(row);
            }

            // Find max cost for scaling
            let maxCost = 0;
            transposedMatrix.forEach(row => {
                row.forEach(cost => {
                    maxCost = Math.max(maxCost, cost);
                });
            });

            // Calculate totals
            const userTotals = {};
            const modelTotals = {};
            users.forEach(u => {
                userTotals[u] = Object.values(userModelCosts[u] || {}).reduce((a, b) => a + b, 0);
            });
            models.forEach((m, idx) => {
                modelTotals[m] = transposedMatrix[idx].reduce((a, b) => a + b, 0);
            });

            // Render the two distribution charts
            renderCostByUserChart(models, users, modelDisplayNames, transposedMatrix, userTotals, modelTotals, maxCost);
            renderCostMatrixChart(models, modelDisplayNames, users, transposedMatrix, maxCost);
        }

        function renderCostByUserChart(models, users, modelDisplayNames, transposedMatrix, userTotals, modelTotals, maxCost) {
            const ctx = document.getElementById('costByUserChart');
            if (!ctx) return;

            const colors = [
                '#667eea', '#764ba2', '#f5576c', '#f093fb', '#4facfe', '#00f2fe',
                '#43e97b', '#38f9d7', '#fa709a', '#fee140', '#30b0fe', '#4facfe',
                '#ff6b6b', '#ee5a6f', '#c44569', '#f8b500', '#56ab91', '#a8e6cf'
            ];

            const datasets = [];
            for (let modelIdx = 0; modelIdx < models.length; modelIdx++) {
                const model = models[modelIdx];
                const displayName = modelDisplayNames[model] || model;
                const modelData = [];

                for (let userIdx = 0; userIdx < users.length; userIdx++) {
                    modelData.push(parseFloat(transposedMatrix[modelIdx][userIdx].toFixed(2)));
                }

                datasets.push({
                    label: displayName,
                    data: modelData,
                    backgroundColor: colors[modelIdx % colors.length],
                    borderColor: colors[modelIdx % colors.length],
                    borderWidth: 1
                });
            }

            if (chartInstances['costByUserChart']) chartInstances['costByUserChart'].destroy();
            chartInstances['costByUserChart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: users,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            stacked: true,
                            title: { display: true, text: 'Cost ($)' }
                        },
                        y: { stacked: true }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { padding: 15, font: { size: 11 }, boxWidth: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': $' + context.parsed.x.toFixed(4);
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderCostMatrixChart(models, modelDisplayNames, users, transposedMatrix, maxCost) {
            const ctx = document.getElementById('costMatrixChart');
            if (!ctx) return;

            const colors = [
                '#667eea', '#764ba2', '#f5576c', '#f093fb', '#4facfe', '#00f2fe',
                '#43e97b', '#38f9d7', '#fa709a', '#fee140', '#30b0fe', '#4facfe'
            ];

            const datasets = [];
            for (let userIdx = 0; userIdx < users.length; userIdx++) {
                const user = users[userIdx];
                datasets.push({
                    label: user,
                    data: transposedMatrix.map(row => parseFloat(row[userIdx].toFixed(2))),
                    backgroundColor: colors[userIdx % colors.length],
                    borderColor: colors[userIdx % colors.length],
                    borderWidth: 1
                });
            }

            if (chartInstances['costMatrixChart']) chartInstances['costMatrixChart'].destroy();
            chartInstances['costMatrixChart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: models.map(m => modelDisplayNames[m] || m),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            stacked: true,
                            title: { display: true, text: 'Cost ($)' }
                        },
                        y: { stacked: true }
                    },
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: { padding: 15, font: { size: 12 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': $' + context.parsed.x.toFixed(4);
                                }
                            }
                        }
                    }
                }
            });
        }

        function getColorForIndex(index) {
            const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#43e97b', '#38f9d7', '#ff9900', '#ec7211'];
            return colors[index % colors.length];
        }

        function renderTokenCharts(data) {
            // Tokens by User (Stacked)
            const userTokens = data.user_tokens || {};
            const users = Object.keys(userTokens);
            createStackedBarChart('tokensByUserChart', 'Token Usage by User',
                users,
                users.map(u => userTokens[u].input),
                users.map(u => userTokens[u].output));

            // Tokens by Model (Stacked) - with display names
            // Use filtered data for graphs (only models with >= 25 invocations)
            const modelTokens = data.model_tokens_for_graphs || {};
            const models = Object.keys(modelTokens);
            const modelDisplayNames = data.model_display_names_for_graphs || {};
            const modelLabels = models.map(m => modelDisplayNames[m] || m);
            createStackedBarChart('tokensByModelChart', 'Token Usage by Model',
                modelLabels,
                models.map(m => modelTokens[m].input),
                models.map(m => modelTokens[m].output));
        }

        function renderInvocationCharts(data) {
            // Invocations by User
            createBarChart('invocationsByUserChart', 'Invocations by User',
                Object.keys(data.user_invocations),
                Object.values(data.user_invocations),
                '#43e97b', false);

            // Invocations by Model - with display names
            // Use filtered data for graphs (only models with >= 25 invocations)
            const modelUsage = data.model_usage_for_graphs || {};
            const modelDisplayNames = data.model_display_names_for_graphs || {};
            const modelLabels = Object.keys(modelUsage).map(m => modelDisplayNames[m] || m);
            createDoughnutChart('invocationsByModelChart', 'Invocations by Model',
                modelLabels,
                Object.values(modelUsage));

            // Daily Trend
            const dailyTrendDates = Object.keys(data.daily_trend).map(date => {
                // Format dates to YYYY-MM-DD (remove time portion)
                // Handle both CloudWatch timestamp format and simple date format
                if (date.includes('T') || date.includes(' ')) {
                    // CloudWatch timestamp format: "2025-11-05 00:00:00.000"
                    return date.split(' ')[0];  // Extract just the date part
                }
                return date;
            });
            createLineChart('dailyTrendChart', 'Daily Invocation Trend',
                dailyTrendDates,
                Object.values(data.daily_trend),
                '#667eea', false);
        }

        function createBarChart(canvasId, title, labels, data, color, isCurrency) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: title,
                        data: data,
                        backgroundColor: color,
                        borderColor: color,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: title, font: { size: 16, weight: 'bold' } },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (isCurrency) {
                                        label += '$' + parseFloat(context.parsed.y).toFixed(2);
                                    } else {
                                        label += formatNumber(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return isCurrency ? '$' + value.toFixed(2) : formatNumber(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        function createStackedBarChart(canvasId, title, labels, inputData, outputData) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Input Tokens',
                            data: inputData,
                            backgroundColor: '#4facfe',
                            borderWidth: 0
                        },
                        {
                            label: 'Output Tokens',
                            data: outputData,
                            backgroundColor: '#00f2fe',
                            borderWidth: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: title, font: { size: 16, weight: 'bold' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + formatNumber(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: { stacked: true },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatNumber(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        function createMultiLineChart(canvasId, title, labels, datasets) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets.map(ds => ({
                        ...ds,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: title, font: { size: 16, weight: 'bold' } },
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    label += '$' + parseFloat(context.parsed.y).toFixed(2);
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            stacked: false,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function createDailyLineChart(canvasId, title, dates, datasets) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates.map(d => {
                        // Parse date string and format as YYYY-MM-DD
                        // Handle both CloudWatch timestamp format and simple date format
                        let dateObj;
                        if (d.includes('T') || d.includes(' ')) {
                            // CloudWatch timestamp format: "2025-11-05 00:00:00.000"
                            dateObj = new Date(d.replace(' ', 'T'));
                        } else {
                            // Simple date format: "2025-11-05"
                            dateObj = new Date(d + 'T00:00:00Z');
                        }
                        const year = dateObj.getUTCFullYear();
                        const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
                        const day = String(dateObj.getUTCDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    }),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: title, font: { size: 16, weight: 'bold' } },
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: { size: 11 },
                                boxWidth: 12
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    label += '$' + parseFloat(context.parsed.y).toFixed(4);
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            stacked: false,
                            title: {
                                display: true,
                                text: 'Cost ($)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function createLineChart(canvasId, title, labels, data, color, isCurrency) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: title,
                        data: data,
                        borderColor: color,
                        backgroundColor: color + '33',
                        tension: 0.4,
                        fill: true,
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: title, font: { size: 16, weight: 'bold' } },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (isCurrency) {
                                        label += '$' + parseFloat(context.parsed.y).toFixed(2);
                                    } else {
                                        label += formatNumber(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return isCurrency ? '$' + value.toFixed(2) : formatNumber(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        function createDoughnutChart(canvasId, title, labels, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#43e97b', '#38f9d7'];

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: title, font: { size: 16, weight: 'bold' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + formatNumber(context.parsed);
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderTables(data) {
            // Model Table
            const modelTableBody = document.getElementById('modelTableBody');
            const modelTokens = data.model_tokens || {};
            const modelCosts = data.model_costs || {};
            const modelInvocations = data.model_invocations || {};
            const modelDisplayNames = data.model_display_names || {};

            const modelRows = Object.keys(modelInvocations).map(model => ({
                model: model,
                displayName: modelDisplayNames[model] || model,
                invocations: modelInvocations[model],
                inputTokens: modelTokens[model]?.input || 0,
                outputTokens: modelTokens[model]?.output || 0,
                cost: modelCosts[model] || 0
            })).sort((a, b) => b.cost - a.cost);

            modelTableBody.innerHTML = modelRows.map(row => `
                <tr>
                    <td><strong title="${row.model}">${row.displayName}</strong></td>
                    <td class="number">${formatNumber(row.invocations)}</td>
                    <td class="number">${formatNumber(row.inputTokens)}</td>
                    <td class="number">${formatNumber(row.outputTokens)}</td>
                    <td class="number cost">${formatCost(row.cost)}</td>
                </tr>
            `).join('');

            // User Table
            const userTableBody = document.getElementById('userTableBody');
            const userTokens = data.user_tokens || {};
            const userCosts = data.user_costs || {};
            const userInvocations = data.user_invocations || {};

            const userRows = Object.keys(userInvocations).map(user => ({
                user: user,
                invocations: userInvocations[user],
                inputTokens: userTokens[user]?.input || 0,
                outputTokens: userTokens[user]?.output || 0,
                cost: userCosts[user] || 0
            })).sort((a, b) => b.cost - a.cost);

            userTableBody.innerHTML = userRows.map(row => `
                <tr>
                    <td><strong>${row.user}</strong></td>
                    <td class="number">${formatNumber(row.invocations)}</td>
                    <td class="number">${formatNumber(row.inputTokens)}</td>
                    <td class="number">${formatNumber(row.outputTokens)}</td>
                    <td class="number">${formatNumber(row.inputTokens + row.outputTokens)}</td>
                    <td class="number cost">${formatCost(row.cost)}</td>
                </tr>
            `).join('');
        }

        // Load data on page load
        loadData();

        // Auto-refresh every 5 minutes
        setInterval(loadData, 300000);
    </script>
</body>
</html>
